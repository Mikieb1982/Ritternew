<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple Platformer - Mobile Enhanced</title>
    <style>
        /* Basic Reset */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center;    /* Center vertically */
            width: 100vw;           /* Full viewport width */
            height: 100vh;          /* Full viewport height */
            margin: 0;
            background-color: #111; /* Dark background outside game */
            font-family: sans-serif;
            color: white;
            overflow: hidden; /* Prevent scrollbars */
        }
        #game-container {
            border: 2px solid white; /* Keep border for non-fullscreen */
            position: relative; /* Needed for absolute positioning of UI & controls */
            /* Dimensions will be set by JS, but provide fallback/initial */
            width: 800px;
            height: 450px;
            max-width: 100%; /* Ensure it doesn't overflow body */
            max-height: 100%;
            overflow: hidden; /* Hide anything spilling out */
        }
        canvas {
            display: block; /* Prevent extra space below canvas */
            width: 100%;    /* Fill container width */
            height: 100%;   /* Fill container height */
            /* Background color is fallback if image fails */
            background-color: #87CEEB;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui-elements {
             position: absolute;
             top: 10px;
             left: 10px;
             background-color: rgba(0,0,0,0.6);
             padding: 8px;
             border-radius: 5px;
             font-size: clamp(0.8rem, 2vw, 1.1rem); /* Responsive font size */
             color: #FFFF00; /* Yellow score */
             text-shadow: 1px 1px 1px black;
             z-index: 10; /* Ensure UI is above canvas */
        }
        #instructions {
             /* Instructions removed from HTML, can be added back if needed */
             display: none; /* Hide instructions by default */
        }

        /* --- Touch Controls Styling --- */
        .touch-control {
            position: absolute;
            z-index: 20; /* Above UI */
            display: none; /* Hidden by default, shown via media query */
            user-select: none;
            -webkit-user-select: none;
            opacity: 0.6; /* Semi-transparent */
            border-radius: 50%;
        }
        #joystickContainer {
            bottom: 15px;
            left: 15px;
            width: 120px; /* Adjust size as needed */
            height: 120px;
            /* background-color: rgba(100, 100, 100, 0.4); */ /* Optional base background */
            /* border: 2px solid rgba(255, 255, 255, 0.5); */
            pointer-events: none; /* Container doesn't receive events */
        }
        #joystickBase {
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background-color: rgba(80, 80, 80, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.5);
            pointer-events: auto; /* Base receives events */
        }
        #joystickKnob {
            position: absolute;
            width: 50%; /* Relative to base */
            height: 50%; /* Relative to base */
            border-radius: 50%;
            background-color: rgba(200, 200, 200, 0.7);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%); /* Center knob */
            pointer-events: none; /* Knob itself doesn't need events */
            transition: transform 0.05s linear;
        }
        #jumpButton {
            bottom: 25px; /* Align better with joystick */
            right: 25px;
            width: 80px; /* Fixed size jump button */
            height: 80px;
            background-color: rgba(50, 200, 50, 0.6); /* Greenish jump button */
            border: 2px solid rgba(255, 255, 255, 0.7);
            display: flex; /* Use flex to center text/icon */
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            pointer-events: auto; /* Button receives events */
        }
         #jumpButton:active {
             background-color: rgba(100, 255, 100, 0.8); /* Brighter green when active */
         }

        /* --- Media Queries for Controls and Layout --- */
        /* Show controls only on touch devices in landscape */
        @media (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .touch-control {
                display: block; /* Show joystick container */
            }
             #jumpButton {
                 display: flex; /* Show jump button */
             }
        }
        /* Hide controls on non-touch devices or portrait */
        @media (hover: hover) and (pointer: fine), (orientation: portrait) {
            .touch-control {
                display: none;
            }
             #jumpButton {
                 display: none;
             }
        }
         /* Force landscape-like layout on larger screens */
         @media (min-width: 600px) and (min-height: 400px) {
              #game-container {
                  /* Use aspect ratio for larger screens if desired */
                  /* aspect-ratio: 16 / 9; */
                  /* Or keep fixed size */
                   width: 800px;
                   height: 450px;
              }
         }


    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas> <div id="ui-elements">
            Score: <span id="score">0</span> / <span id="total-collectibles">0</span>
        </div>
        <div id="joystickContainer" class="touch-control">
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <button id="jumpButton" class="touch-control">JUMP</button>
    </div>
    <script>
        // --- Strict mode and IIFE ---
        (function() {
            'use strict';

            // --- DOM Elements ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreSpan = document.getElementById('score');
            const totalCollectiblesSpan = document.getElementById('total-collectibles');
            const gameContainer = document.getElementById('game-container');
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            const jumpButton = document.getElementById('jumpButton');


            // --- Essential Element Check ---
            if (!canvas || !ctx || !scoreSpan || !totalCollectiblesSpan || !gameContainer || !joystickContainer || !joystickBase || !joystickKnob || !jumpButton) {
                alert("Fatal Error: Required elements not found!");
                return;
            }

            // --- Game Configuration ---
            const gravity = 800;
            const playerSpeed = 200;
            const jumpPower = 450;
            // Make player size relative to canvas height for better scaling?
            let playerWidth = 32;
            let playerHeight = 42;
            let collectibleSize = 35;
            let obstacleTractorWidth = 60;
            let obstacleTractorHeight = 45;
            let obstacleFamilyWidth = 30;
            let obstacleFamilyHeight = 50;
            const JOYSTICK_DEAD_ZONE = 10; // Pixels


            // --- Assets ---
            const assetsToLoad = {
                player: { img: new Image(), loaded: false, src: 'assets/knight_jump.png' },
                background: { img: new Image(), loaded: false, src: 'assets/background1.png'}, // ADDED Background
                therme: { img: new Image(), loaded: false, src: 'assets/therme.png' },
                freibad: { img: new Image(), loaded: false, src: 'assets/freibad.png' },
                kulturzentrum: { img: new Image(), loaded: false, src: 'assets/kulturzentrum.png' },
                bahnhof: { img: new Image(), loaded: false, src: 'assets/bahnhof.png' },
                post: { img: new Image(), loaded: false, src: 'assets/post.png' },
                rathaus: { img: new Image(), loaded: false, src: 'assets/rathaus.png' },
                burg: { img: new Image(), loaded: false, src: 'assets/burg.png' },
                tractor: { img: new Image(), loaded: false, src: 'assets/tractor.png' },
                family: { img: new Image(), loaded: false, src: 'assets/family.png' },
            };
            let assetsLoadedCount = 0;
            const totalAssets = Object.keys(assetsToLoad).length;
            let allAssetsLoaded = false;
            let backgroundPattern = null; // For tiled background

            // --- Game State ---
            let score = 0;
            let gameWon = false;

            // Player object - positions will be updated on resize
            const player = {
                x: 50, y: 300, // Initial values, will be adjusted
                width: playerWidth, height: playerHeight,
                velocityX: 0, velocityY: 0,
                isGrounded: false,
                spawnX: 50, spawnY: 300 // Relative spawn? Maybe %?
            };

            // Platforms - positions need to be relative or recalculated on resize
            // Let's define them relative to initial 800x450 canvas for now
            // We'll scale drawing later
            const baseWidth = 800;
            const baseHeight = 450;
            let platforms = [
                { x: 0, y: baseHeight - 20, width: baseWidth, height: 20, color: '#228B22' },
                { x: 100, y: baseHeight - 100, width: 150, height: 15, color: '#A0522D' },
                { x: 350, y: baseHeight - 180, width: 200, height: 15, color: '#A0522D' },
                { x: 600, y: baseHeight - 120, width: 100, height: 15, color: '#A0522D' },
                { x: 400, y: baseHeight - 260, width: 80, height: 15, color: '#A0522D' },
                { x: 150, y: baseHeight - 330, width: 100, height: 15, color: '#A0522D' }
            ];

            // Collectibles - positions relative to 800x450
            let collectibles = [
                { x: 150, y: baseHeight - 100 - collectibleSize - 10, assetKey: 'therme', collected: false },
                { x: 450, y: baseHeight - 180 - collectibleSize - 10, assetKey: 'freibad', collected: false },
                { x: 650, y: baseHeight - 120 - collectibleSize - 10, assetKey: 'bahnhof', collected: false },
                { x: 420, y: baseHeight - 260 - collectibleSize - 10, assetKey: 'post', collected: false },
                { x: 180, y: baseHeight - 330 - collectibleSize - 10, assetKey: 'rathaus', collected: false },
                { x: 50, y: 50, assetKey: 'kulturzentrum', collected: false },
                { x: 700, y: 50, assetKey: 'burg', collected: false }
            ];
            collectibles.forEach(c => { c.width = collectibleSize; c.height = collectibleSize; });
            const totalCollectibles = collectibles.length;
            totalCollectiblesSpan.textContent = totalCollectibles;

            // Obstacles - positions relative to 800x450
            let obstacles = [
                { x: 250, y: baseHeight - 20 - obstacleTractorHeight, width: obstacleTractorWidth, height: obstacleTractorHeight, assetKey: 'tractor' },
                { x: 500, y: baseHeight - 20 - obstacleFamilyHeight, width: obstacleFamilyWidth, height: obstacleFamilyHeight, assetKey: 'family' }
            ];

            // Input tracking
            const keysPressed = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, ' ': false };

            // Touch control state
            let joystickActive = false;
            let joystickStartX = 0;
            let joystickStartY = 0;
            let joystickBaseRect = null;
            let joystickRadius = 0;
            let jumpButtonPressed = false; // Track jump button state

            let lastTime = 0;
            let scaleX = 1; // Scaling factors for drawing
            let scaleY = 1;

            // --- Asset Loading ---
            function assetLoaded(assetKey) {
                console.log(`Asset loaded: ${assetKey}`);
                assetsLoadedCount++;
                // Create background pattern once loaded
                if (assetKey === 'background' && assetsToLoad.background.loaded) {
                     backgroundPattern = ctx.createPattern(assetsToLoad.background.img, 'repeat');
                }
                if (assetsLoadedCount === totalAssets) {
                    console.log("All assets loaded.");
                    allAssetsLoaded = true;
                    resizeCanvas(); // Initial resize after assets (esp. background) are loaded
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
            // AssetLoadError (same as before)
            function assetLoadError(assetKey, event) {
                console.error(`Failed to load asset: ${assetKey}. Event:`, event);
                assetsLoadedCount++;
                 if (assetsLoadedCount === totalAssets) {
                    console.warn("Finished loading assets, but some may have failed.");
                    allAssetsLoaded = true;
                    resizeCanvas(); // Still resize and start
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }
            // LoadAssets (same as before)
            function loadAssets() {
                console.log("Loading assets...");
                for (const key in assetsToLoad) {
                    const asset = assetsToLoad[key];
                    asset.img.onload = () => { asset.loaded = true; assetLoaded(key); };
                    asset.img.onerror = (e) => assetLoadError(key, e);
                    asset.img.src = asset.src;
                }
            }

            // --- Canvas Resizing ---
            function resizeCanvas() {
                // Get the actual display size of the container
                const displayWidth = gameContainer.clientWidth;
                const displayHeight = gameContainer.clientHeight;

                // Update the canvas rendering resolution
                canvas.width = displayWidth;
                canvas.height = displayHeight;

                // Calculate scaling factors based on original design size
                scaleX = canvas.width / baseWidth;
                scaleY = canvas.height / baseHeight;

                // Adjust player size based on scale (optional, keeps pixel size consistent)
                // player.width = playerWidth * scaleX;
                // player.height = playerHeight * scaleY;
                // collectibleSize = 35 * Math.min(scaleX, scaleY); // Scale collectibles too

                // Update joystick dimensions if needed
                if (joystickBase) {
                    joystickBaseRect = joystickBase.getBoundingClientRect();
                    joystickRadius = joystickBaseRect.width / 2 - joystickKnob.offsetWidth / 2;
                }

                 // Re-create background pattern with potentially new canvas size context if needed
                 if (assetsToLoad.background.loaded) {
                      backgroundPattern = ctx.createPattern(assetsToLoad.background.img, 'repeat');
                 }

                console.log(`Canvas resized to: ${canvas.width}x${canvas.height}, Scale: ${scaleX.toFixed(2)}, ${scaleY.toFixed(2)}`);
            }


            // --- Input Handling ---
            function handleKeyDown(e) { if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = true; } }
            function handleKeyUp(e) { if (keysPressed.hasOwnProperty(e.key)) { e.preventDefault(); keysPressed[e.key] = false; } }

            // --- Touch Input ---
            function handleJoystickStart(e) {
                if (gameWon) return;
                e.preventDefault();
                joystickBaseRect = joystickBase.getBoundingClientRect();
                joystickRadius = joystickBaseRect.width / 2 - joystickKnob.offsetWidth / 2;
                joystickActive = true;
                const touch = e.touches[0];
                const baseCenterX = joystickBaseRect.left + joystickBaseRect.width / 2;
                const baseCenterY = joystickBaseRect.top + joystickBaseRect.height / 2;
                joystickStartX = touch.clientX - baseCenterX;
                joystickStartY = touch.clientY - baseCenterY;
                handleJoystickMove(e); // Update knob position immediately
            }

            function handleJoystickMove(e) {
                if (!joystickActive || gameWon) return;
                e.preventDefault();
                const touch = e.touches[0];
                const baseCenterX = joystickBaseRect.left + joystickBaseRect.width / 2;
                const baseCenterY = joystickBaseRect.top + joystickBaseRect.height / 2;
                let deltaX = touch.clientX - baseCenterX;
                let deltaY = touch.clientY - baseCenterY; // Keep track of Y for potential future use
                const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                let clampedX = deltaX;
                let clampedY = deltaY;

                if (dist > joystickRadius) {
                    const scale = joystickRadius / dist;
                    clampedX = deltaX * scale;
                    clampedY = deltaY * scale;
                }
                joystickKnob.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;

                // Update keysPressed based on joystick horizontal position
                if (deltaX < -JOYSTICK_DEAD_ZONE) {
                    keysPressed.ArrowLeft = true;
                    keysPressed.ArrowRight = false;
                } else if (deltaX > JOYSTICK_DEAD_ZONE) {
                    keysPressed.ArrowRight = true;
                    keysPressed.ArrowLeft = false;
                } else {
                    keysPressed.ArrowLeft = false;
                    keysPressed.ArrowRight = false;
                }
            }

            function handleJoystickEnd(e) {
                 if (!joystickActive) return;
                 e.preventDefault();
                 joystickKnob.style.transform = 'translate(-50%, -50%)'; // Reset knob
                 joystickActive = false;
                 keysPressed.ArrowLeft = false; // Stop movement
                 keysPressed.ArrowRight = false;
            }

            function handleJumpPress(e) {
                if (gameWon) return;
                e.preventDefault();
                jumpButtonPressed = true;
                // Directly set jump key state for update loop to handle
                keysPressed[' '] = true; // Use space key state for jump button
            }

            function handleJumpRelease(e) {
                 if (gameWon) return;
                 e.preventDefault();
                 jumpButtonPressed = false;
                 keysPressed[' '] = false; // Release space key state
            }


            // --- Collision Helper (AABB - Unchanged) ---
            function checkCollision(rect1, rect2) { /* ... same as before ... */
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            // --- Reset Player (Unchanged) ---
            function resetPlayer() { /* ... same as before ... */
                console.log("Player reset!");
                player.x = player.spawnX;
                player.y = player.spawnY;
                player.velocityX = 0;
                player.velocityY = 0;
                player.isGrounded = false;
            }

            // --- Game Logic ---
            function update(dt) {
                if (!allAssetsLoaded || dt > 0.1 || gameWon) return;

                // --- Horizontal Movement (Driven by keysPressed) ---
                player.velocityX = 0;
                if (keysPressed.ArrowLeft) { player.velocityX = -playerSpeed; }
                if (keysPressed.ArrowRight) { player.velocityX = playerSpeed; }
                let potentialX = player.x + player.velocityX * dt;

                // --- Vertical Movement (Gravity) ---
                player.velocityY += gravity * dt;
                let potentialY = player.y + player.velocityY * dt;

                player.isGrounded = false;

                // --- Collision Detection & Resolution with Platforms ---
                // Important: Collision checks now use the base coordinates
                let adjustedY = potentialY;
                let adjustedX = potentialX;

                for (const platform of platforms) {
                     // Scale player rect for collision check against base coordinates
                     const playerRect = {
                         x: potentialX, y: potentialY,
                         width: player.width, height: player.height
                     };
                     // Platform rect uses base coordinates directly
                     const platformRect = {
                         x: platform.x, y: platform.y,
                         width: platform.width, height: platform.height
                     };

                    if (checkCollision(playerRect, platformRect)) {
                        // Vertical Resolution
                        if (player.velocityY >= 0 && (player.y + player.height) <= platform.y + 1) {
                            adjustedY = platform.y - player.height;
                            player.velocityY = 0;
                            player.isGrounded = true;
                        } else if (player.velocityY < 0 && player.y >= (platform.y + platform.height - 1)) {
                             adjustedY = platform.y + platform.height;
                             player.velocityY = 0;
                        }

                        // Horizontal Resolution (recheck with adjusted Y)
                         const playerVerticallyAdjustedRect = { x: potentialX, y: adjustedY, width: player.width, height: player.height };
                         if(checkCollision(playerVerticallyAdjustedRect, platformRect)) {
                             if (player.velocityX > 0 && (player.x + player.width) <= platform.x + 1) {
                                 adjustedX = platform.x - player.width;
                                 player.velocityX = 0;
                             } else if (player.velocityX < 0 && player.x >= (platform.x + platform.width - 1)) {
                                 adjustedX = platform.x + platform.width;
                                 player.velocityX = 0;
                             }
                         }
                    }
                }
                player.x = adjustedX;
                player.y = adjustedY;

                // --- Jumping (Driven by keysPressed) ---
                if ((keysPressed.ArrowUp || keysPressed[' ']) && player.isGrounded) {
                    player.velocityY = -jumpPower;
                    player.isGrounded = false;
                    // Important: Reset the key state immediately after jump starts if using button press
                    // Otherwise player might multi-jump if button held
                    if (jumpButtonPressed) {
                         keysPressed[' '] = false; // Prevent multi-jump from button hold
                    }
                }

                // --- Collision with Collectibles ---
                 for (let i = collectibles.length - 1; i >= 0; i--) {
                    const item = collectibles[i];
                     // Scale player rect for collision check
                     const playerHitbox = { x: player.x, y: player.y, width: player.width, height: player.height };
                     // Scale item rect for collision check
                     const itemHitbox = { x: item.x, y: item.y, width: item.width, height: item.height };

                    if (!item.collected && checkCollision(playerHitbox, itemHitbox)) {
                        item.collected = true;
                        score++;
                        scoreSpan.textContent = score;
                        if (score === totalCollectibles) { gameWon = true; console.log("YOU WIN!"); }
                    }
                }

                // --- Collision with Obstacles ---
                for (const obs of obstacles) {
                     const playerHitbox = { x: player.x, y: player.y, width: player.width, height: player.height };
                     const obsHitbox = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };
                    if (checkCollision(playerHitbox, obsHitbox)) {
                        resetPlayer();
                        break;
                    }
                }

                // --- Boundary Checking (using base coordinates) ---
                if (player.x < 0) { player.x = 0; player.velocityX = 0; }
                if (player.x + player.width > baseWidth) { player.x = baseWidth - player.width; player.velocityX = 0; }
                if (player.y > baseHeight + 100) { resetPlayer(); }
                if (player.y < 0) { player.y = 0; if(player.velocityY < 0) player.velocityY = 0; }
            }

            // --- Drawing ---
            function draw() {
                if (!allAssetsLoaded) { /* Loading message... */ return; }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // --- Draw Background ---
                if (backgroundPattern) {
                    ctx.fillStyle = backgroundPattern;
                    ctx.save();
                    // Optional: Translate pattern if needed for parallax/scrolling later
                    // ctx.translate(offsetX, offsetY);
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                } else if (assetsToLoad.background.loaded) {
                    // Fallback: Stretch background if pattern failed
                    ctx.drawImage(assetsToLoad.background.img, 0, 0, canvas.width, canvas.height);
                } else {
                    // Fallback color if image not loaded
                     ctx.fillStyle = '#87CEEB';
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                }


                // --- Apply Scaling for Game Objects ---
                ctx.save();
                ctx.scale(scaleX, scaleY); // Apply scaling for all subsequent draws

                // Draw platforms (using base coordinates, scaled by ctx.scale)
                platforms.forEach(platform => {
                    ctx.fillStyle = platform.color || '#666';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                });

                 // Draw obstacles (using base coordinates)
                 obstacles.forEach(obs => {
                    const asset = assetsToLoad[obs.assetKey];
                    if (asset && asset.loaded) {
                        ctx.drawImage(asset.img, obs.x, obs.y, obs.width, obs.height);
                    } else { ctx.fillStyle = 'purple'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); }
                });

                // Draw collectibles (using base coordinates)
                collectibles.forEach(item => {
                    if (!item.collected) {
                        const asset = assetsToLoad[item.assetKey];
                        if (asset && asset.loaded) {
                            ctx.drawImage(asset.img, item.x, item.y, item.width, item.height);
                        } else { ctx.fillStyle = 'gold'; ctx.fillRect(item.x, item.y, item.width, item.height); }
                    }
                });

                // Draw player (using base coordinates)
                const playerAsset = assetsToLoad.player;
                if (playerAsset.loaded) {
                    ctx.drawImage(playerAsset.img, player.x, player.y, player.width, player.height);
                } else { ctx.fillStyle = 'red'; ctx.fillRect(player.x, player.y, player.width, player.height); }

                // --- Restore context before drawing UI that shouldn't be scaled ---
                ctx.restore();


                 // Draw Win Message (Not scaled)
                 if (gameWon) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);
                    ctx.font = `bold ${Math.min(30, 5 * scaleX)}px sans-serif`; // Scale font size slightly
                    ctx.fillStyle = '#FFFF00';
                    ctx.textAlign = 'center';
                    ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
                    ctx.font = `${Math.min(20, 4 * scaleX)}px sans-serif`;
                     ctx.fillStyle = 'white';
                    ctx.fillText('All items collected!', canvas.width / 2, canvas.height / 2 + 30 * scaleY);
                 }
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                update(dt);
                draw();

                requestAnimationFrame(gameLoop);
            }

            // --- Initialization ---
            function init() {
                console.log("Initializing mobile enhanced platformer...");
                // Keyboard Listeners
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                // Touch Listeners
                joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
                joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
                joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
                joystickContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false }); // Handle cancelled touches
                jumpButton.addEventListener('touchstart', handleJumpPress, { passive: false });
                jumpButton.addEventListener('touchend', handleJumpRelease, { passive: false });
                jumpButton.addEventListener('touchcancel', handleJumpRelease, { passive: false });

                // Resize Listener
                window.addEventListener('resize', resizeCanvas);
                // Initial load
                loadAssets(); // Load assets; resize & game loop start on completion
            }

            // --- Start the game ---
            document.addEventListener('DOMContentLoaded', init);

        })(); // End of IIFE
    </script>
</body>
</html>

