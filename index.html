<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Platformer</title>
    <style>
        body {
            display: flex;
            flex-direction: column; /* Stack canvas and instructions */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #444; /* Neutral background */
            font-family: sans-serif;
        }
        #game-container {
            border: 2px solid white;
            margin-bottom: 10px; /* Space between canvas and text */
        }
        canvas {
            display: block;
            background-color: #87CEEB; /* Light blue sky background */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #instructions {
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="450"></canvas>
    </div>
    <div id="instructions">Use Left/Right Arrows to Move, Up Arrow/Space to Jump</div>

    <script>
        // --- Strict mode and IIFE ---
        (function() {
            'use strict';

            // --- DOM Elements ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- Essential Element Check ---
            if (!canvas || !ctx) {
                alert("Fatal Error: Canvas not found!");
                return;
            }

            // --- Game Configuration ---
            const gravity = 800; // Pixels per second squared
            const playerSpeed = 200; // Horizontal speed, pixels per second
            const jumpPower = 450; // Initial upward velocity, pixels per second
            const playerWidth = 32; // Player dimensions
            const playerHeight = 42; // Player dimensions (adjust if using different sprite)

            // --- Assets ---
            // Using knight_jump as a static representation for simplicity.
            // You could swap this for knight_run.gif if preferred, but animation isn't handled here.
            const playerAsset = { img: new Image(), loaded: false, src: 'assets/knight_jump.png' };
            let assetsLoadedCount = 0;
            const totalAssets = 1; // Just the player asset for now
            let allAssetsLoaded = false;

            // --- Game State ---
            const player = {
                x: canvas.width / 2 - playerWidth / 2,
                y: canvas.height - playerHeight - 50, // Start near bottom
                width: playerWidth,
                height: playerHeight,
                velocityX: 0,
                velocityY: 0,
                isGrounded: false
            };

            // Platform definitions: { x, y, width, height }
            // Y coordinate is the top edge of the platform.
            const platforms = [
                // Ground platform
                { x: 0, y: canvas.height - 20, width: canvas.width, height: 20, color: '#228B22' }, // ForestGreen
                // Some ledges
                { x: 100, y: canvas.height - 100, width: 150, height: 15, color: '#A0522D' }, // Sienna
                { x: 350, y: canvas.height - 180, width: 200, height: 15, color: '#A0522D' },
                { x: 600, y: canvas.height - 260, width: 100, height: 15, color: '#A0522D' },
                { x: 400, y: canvas.height - 340, width: 80, height: 15, color: '#A0522D' },
                { x: 150, y: canvas.height - 250, width: 100, height: 15, color: '#A0522D' }
            ];

            // Input tracking
            const keysPressed = {
                ArrowUp: false,
                ArrowDown: false, // Not used currently, but can be added
                ArrowLeft: false,
                ArrowRight: false,
                ' ': false // Space bar for jump
            };

            let lastTime = 0;

            // --- Asset Loading ---
            function assetLoaded(assetKey) {
                console.log(`Asset loaded: ${assetKey}`);
                assetsLoadedCount++;
                if (assetsLoadedCount === totalAssets) {
                    console.log("All assets loaded.");
                    allAssetsLoaded = true;
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }

            function assetLoadError(assetKey, event) {
                console.error(`Failed to load asset: ${assetKey}. Event:`, event);
                alert(`Error loading image: ${assetKey}\nGame might not display correctly.`);
                assetsLoadedCount++;
                 if (assetsLoadedCount === totalAssets) {
                    console.warn("Finished loading assets, but some failed.");
                    allAssetsLoaded = true;
                    lastTime = performance.now();
                    requestAnimationFrame(gameLoop);
                }
            }

            function loadAssets() {
                console.log("Loading assets...");
                playerAsset.img.onload = () => { playerAsset.loaded = true; assetLoaded('player'); };
                playerAsset.img.onerror = (e) => assetLoadError('player', e);
                playerAsset.img.src = playerAsset.src;
            }

            // --- Input Handling ---
            function handleKeyDown(e) {
                if (keysPressed.hasOwnProperty(e.key)) {
                    e.preventDefault();
                    keysPressed[e.key] = true;
                }
            }

            function handleKeyUp(e) {
                if (keysPressed.hasOwnProperty(e.key)) {
                    e.preventDefault();
                    keysPressed[e.key] = false;
                }
            }

            // --- Game Logic ---
            function update(dt) {
                if (!allAssetsLoaded || dt > 0.1) return; // Skip large dt steps, e.g., after pause/tabbing out

                // --- Horizontal Movement ---
                player.velocityX = 0; // Reset horizontal velocity each frame based on input
                if (keysPressed.ArrowLeft) {
                    player.velocityX = -playerSpeed;
                }
                if (keysPressed.ArrowRight) {
                    player.velocityX = playerSpeed;
                }
                player.x += player.velocityX * dt;

                // --- Vertical Movement (Gravity) ---
                // Apply gravity (increases downward velocity)
                player.velocityY += gravity * dt;
                // Update vertical position based on velocity
                player.y += player.velocityY * dt;

                // Assume not grounded until collision check proves otherwise
                player.isGrounded = false;

                // --- Collision Detection & Resolution with Platforms ---
                for (const platform of platforms) {
                    // Check for collision using AABB (Axis-Aligned Bounding Box)
                    if (player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        player.y < platform.y + platform.height &&
                        player.y + player.height > platform.y)
                    {
                        // Collision detected! Now determine the collision side.

                        // Calculate overlap on each axis
                        const overlapX = (player.width / 2 + platform.width / 2) - Math.abs((player.x + player.width / 2) - (platform.x + platform.width / 2));
                        const overlapY = (player.height / 2 + platform.height / 2) - Math.abs((player.y + player.height / 2) - (platform.y + platform.height / 2));

                        // Determine primary collision axis (smallest overlap resolution)
                        if (overlapY < overlapX) {
                            // Vertical collision is primary

                            // Check if player was moving down (landing) and was previously above the platform
                            // player.velocityY > 0 checks downward movement
                            // (player.y + player.height - player.velocityY * dt <= platform.y) checks if bottom edge was above platform top last frame
                            if (player.velocityY >= 0 && (player.y + player.height - player.velocityY * dt - 1) <= platform.y) {
                                // Landed on top
                                player.isGrounded = true;
                                player.velocityY = 0;
                                player.y = platform.y - player.height; // Snap player top edge of platform
                                // console.log("Landed on platform"); // Debug log
                            }
                            // Check if player was moving up (hitting bottom)
                            else if (player.velocityY < 0 && (player.y - player.velocityY * dt + 1) >= platform.y + platform.height) {
                                // Hit bottom of platform
                                player.velocityY = 0; // Stop upward movement
                                player.y = platform.y + platform.height; // Snap player bottom edge of platform
                                // console.log("Hit bottom of platform"); // Debug log
                            }
                        } else {
                            // Horizontal collision is primary

                             // Check if player was moving right (hitting left side)
                             if (player.velocityX > 0 && (player.x + player.width - player.velocityX * dt -1) <= platform.x) {
                                 player.velocityX = 0; // Stop horizontal movement
                                 player.x = platform.x - player.width; // Snap player to left edge
                                 // console.log("Hit left side"); // Debug log
                             }
                             // Check if player was moving left (hitting right side)
                             else if (player.velocityX < 0 && (player.x - player.velocityX * dt + 1) >= platform.x + platform.width) {
                                 player.velocityX = 0; // Stop horizontal movement
                                 player.x = platform.x + platform.width; // Snap player to right edge
                                 // console.log("Hit right side"); // Debug log
                             }
                        }
                    }
                }


                // --- Jumping ---
                // Allow jump only if grounded
                if ((keysPressed.ArrowUp || keysPressed[' ']) && player.isGrounded) {
                    player.velocityY = -jumpPower; // Apply upward velocity
                    player.isGrounded = false; // No longer grounded
                    // console.log("Jump!"); // Debug log
                }


                // --- Boundary Checking (Canvas Edges) ---
                // Prevent moving off left/right edges
                if (player.x < 0) {
                    player.x = 0;
                    player.velocityX = 0; // Stop movement if hitting edge
                }
                if (player.x + player.width > canvas.width) {
                    player.x = canvas.width - player.width;
                    player.velocityX = 0; // Stop movement if hitting edge
                }
                // Optional: Prevent falling off the bottom (though ground platform should handle this)
                if (player.y > canvas.height) {
                    // Reset player position or handle "death" state
                    player.y = canvas.height - playerHeight - 50;
                    player.x = canvas.width / 2 - playerWidth / 2;
                    player.velocityY = 0;
                    player.isGrounded = false; // Reset grounded status
                }
                // Optional: Prevent jumping off the top
                if (player.y < 0) {
                    player.y = 0;
                    if(player.velocityY < 0) player.velocityY = 0; // Stop upward velocity if hitting ceiling
                }
            }

            // --- Drawing ---
            function draw() {
                if (!allAssetsLoaded) {
                     ctx.fillStyle = 'white';
                     ctx.font = '20px sans-serif';
                     ctx.textAlign = 'center';
                     ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2);
                     return;
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background (already set via CSS)

                // Draw platforms
                platforms.forEach(platform => {
                    ctx.fillStyle = platform.color || '#666'; // Default color if none specified
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                });

                // Draw player
                if (playerAsset.loaded) {
                    ctx.drawImage(playerAsset.img, player.x, player.y, player.width, player.height);
                } else {
                    // Fallback square if asset failed
                    ctx.fillStyle = 'red';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }

                // Optional: Draw collision boxes for debugging
                /*
                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 1;
                ctx.strokeRect(player.x, player.y, player.width, player.height);
                platforms.forEach(platform => {
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                });
                */
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                update(dt);
                draw();

                requestAnimationFrame(gameLoop);
            }

            // --- Initialization ---
            function init() {
                console.log("Initializing simple platformer game...");
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                loadAssets(); // Load assets; game loop starts on completion
            }

            // --- Start the game ---
            document.addEventListener('DOMContentLoaded', init);

        })(); // End of IIFE
    </script>
</body>
</html>
