<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RitterRun - Outrun Style</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- Global Reset & Basic Setup --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            touch-action: manipulation; /* Prevent zooming on touch */
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111; /* Dark background */
        }

        /* --- Arcade Font & Color Palette --- */
        :root {
            --font-pixel: 'Press Start 2P', cursive; /* Arcade font */
            --arcade-magenta: #FF00FF;
            --arcade-cyan: #00FFFF;
            --arcade-yellow: #FFFF00;
            --arcade-orange: #FFA500;
            --arcade-pink: #FF69B4;
            --arcade-blue: #0077FF;
            --arcade-black: #000000;
            --arcade-white: #FFFFFF;
            --text-shadow: 1px 1px 0px var(--arcade-black); /* Simple pixel shadow */
            --text-shadow-strong: 2px 2px 0px var(--arcade-black);
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            font-family: var(--font-pixel); /* Default to pixel font */
        }

        /* --- Game Container --- */
        #game-container {
            position: relative;
            border: 4px solid var(--arcade-white); /* Thicker white border */
            overflow: hidden;
            background-color: var(--arcade-black); /* Default background if canvas fails */
            width: 800px;
            height: 400px;
            max-width: 100%;
            box-sizing: border-box;
            display: block;
            border-radius: 0; /* Sharp corners */
            box-shadow: 0 0 15px var(--arcade-cyan); /* Neon glow */
        }
        @media (max-width: 850px) {
            #game-container {
                width: 100vw;
                height: 50vw; /* Maintain aspect ratio */
                max-height: 100vh;
                max-width: 100vw;
                border: none; /* No border on full screen */
                box-shadow: none; /* No glow on full screen */
            }
            /* Adjust font sizes for smaller screens */
            #scoreDisplay, #livesDisplay { font-size: 1.5em; }
            .poi-overlay h3 { font-size: 1.1em; }
            .poi-overlay p { font-size: 0.9em; }
            #closePoiButton { font-size: 0.9em; }
            .ui-screen h1 { font-size: 2.5em; }
            .ui-screen h2 { font-size: 2em; }
            .ui-screen p { font-size: 1em; }
            .ui-button { font-size: 1em; padding: 10px 20px;}
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Keep pixels sharp */
            image-rendering: crisp-edges;
        }

        /* --- Knight Image --- */
        #knightImage {
            position: absolute;
            display: none;
            pointer-events: none;
            z-index: 10;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* Add a subtle outline */
            filter: drop-shadow(1px 1px 0 black) drop-shadow(-1px -1px 0 black) drop-shadow(1px -1px 0 black) drop-shadow(-1px 1px 0 black);
        }

        /* --- UI Screens (Start/Game Over) --- */
        .ui-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Slightly more opaque black */
            color: var(--arcade-white);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 30;
            padding: 20px;
            font-family: var(--font-pixel); /* Ensure pixel font */
            line-height: 1.8; /* Increase line height for pixel font */
            text-transform: uppercase; /* Classic arcade style */
        }
        .ui-screen h1 {
            font-size: 3.5em; /* Larger title */
            margin-bottom: 25px;
            color: var(--arcade-cyan); /* Bright title color */
            text-shadow: var(--text-shadow-strong);
        }
        .ui-screen h2 { /* Game Over Title */
            font-size: 3em;
            margin-bottom: 25px;
            color: var(--arcade-magenta); /* Different color for Game Over */
            text-shadow: var(--text-shadow-strong);
        }
         /* Special style for the "Burg Reached" title */
        .ui-screen h2.win-title {
             color: var(--arcade-yellow); /* Yellow for winning */
        }
        .ui-screen p {
            font-size: 1.2em;
            margin: 12px 0;
            text-shadow: var(--text-shadow);
        }
        .ui-button {
            padding: 15px 30px; /* Larger padding */
            font-size: 1.3em;
            font-family: var(--font-pixel);
            margin-top: 35px;
            cursor: pointer;
            background-color: var(--arcade-blue); /* Button color */
            border: 2px solid var(--arcade-white); /* White border */
            color: var(--arcade-white); /* White text */
            transition: background-color 0.1s ease, color 0.1s ease;
            border-radius: 0; /* Sharp corners */
            box-shadow: 3px 3px 0px var(--arcade-black); /* Simple shadow */
            text-transform: uppercase;
        }
        .ui-button:hover {
            background-color: var(--arcade-pink); /* Hover color */
            color: var(--arcade-yellow);
        }
        .ui-button:active {
            background-color: var(--arcade-yellow); /* Active color */
            color: var(--arcade-black);
            transform: translate(2px, 2px); /* Button press effect */
            box-shadow: 1px 1px 0px var(--arcade-black);
        }
        .instructions {
            margin-top: 30px;
            font-size: 0.8em !important; /* Smaller instructions */
            color: var(--arcade-cyan);
            line-height: 1.6;
            text-shadow: none;
        }

        /* --- Score & Lives Display --- */
        #scoreDisplay, #livesDisplay {
            position: absolute;
            top: 10px; /* Closer to top */
            font-size: 1.8em; /* Larger font */
            font-family: var(--font-pixel);
            color: var(--arcade-yellow); /* Yellow score/lives */
            text-shadow: var(--text-shadow-strong);
            z-index: 20;
            text-transform: uppercase;
        }
        #scoreDisplay { left: 15px; }
        #livesDisplay { right: 15px; }

        /* --- POI Overlay --- */
        .poi-overlay {
            position: absolute;
            top: 50%; /* Center vertically */
            left: 50%;
            transform: translate(-50%, -50%); /* Center horizontally */
            width: 85%;
            max-width: 600px;
            background-color: rgba(0, 0, 0, 0.9); /* Darker background */
            border: 3px solid var(--arcade-magenta); /* Magenta border */
            border-radius: 0; /* Sharp corners */
            z-index: 50;
            color: var(--arcade-white);
            padding: 25px 30px;
            text-align: center;
            font-family: var(--font-pixel);
            box-shadow: 0 0 10px var(--arcade-magenta); /* Neon glow */
            display: none;
            cursor: pointer;
            line-height: 1.7;
        }
        .poi-overlay.visible { display: block !important; }
        .poi-overlay h3 {
            margin-bottom: 20px;
            font-size: 1.5em;
            color: var(--arcade-yellow); /* Yellow title */
            text-shadow: var(--text-shadow);
            text-transform: uppercase;
        }
        .poi-overlay p {
            font-size: 1em;
            color: var(--arcade-white);
            margin-bottom: 25px;
            text-shadow: var(--text-shadow);
        }
        #closePoiButton { /* Style like other UI buttons */
            padding: 10px 20px;
            font-size: 1em;
            font-family: var(--font-pixel);
            cursor: pointer;
            background-color: var(--arcade-cyan); /* Use a different color */
            border: 2px solid var(--arcade-white);
            color: var(--arcade-black);
            margin-top: 15px;
            border-radius: 0;
            box-shadow: 2px 2px 0px var(--arcade-black);
            text-transform: uppercase;
        }
        #closePoiButton:hover { background-color: var(--arcade-pink); color: var(--arcade-yellow); }
        #closePoiButton:active { background-color: var(--arcade-yellow); color: var(--arcade-black); transform: translate(1px, 1px); box-shadow: 1px 1px 0px var(--arcade-black); }

        /* --- Touch Controls --- */
        #joystickContainer {
            position: fixed;
            bottom: 20px; left: 20px;
            width: 130px; height: 130px; /* Slightly larger */
            z-index: 25;
            display: none; /* Hidden by default, shown via media query */
            pointer-events: none;
        }
        #joystickBase {
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 0, 255, 0.3); /* Semi-transparent magenta */
            border: 3px solid var(--arcade-magenta); /* Magenta border */
            pointer-events: auto;
            box-shadow: 0 0 8px var(--arcade-magenta);
        }
        #joystickKnob {
            position: absolute;
            width: 65px; height: 65px; /* Slightly larger */
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5); /* Brighter knob */
            border: 2px solid var(--arcade-white);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            transition: transform 0.05s linear;
            /* Remove knight image from knob */
            background-image: none;
            opacity: 1;
        }
        #jumpButton {
            position: fixed;
            bottom: 20px; right: 20px;
            width: 18vw; height: 18vw; /* Larger */
            max-width: 90px; max-height: 90px;
            border-radius: 50%;
            background-color: rgba(0, 255, 255, 0.7); /* Semi-transparent cyan */
            border: 3px solid var(--arcade-cyan); /* Cyan border */
            z-index: 25;
            display: none; /* Hidden by default, shown via media query */
            color: var(--arcade-black);
            font-family: var(--font-pixel);
            font-size: 1.1em; /* Adjust size if needed */
            font-weight: normal; /* Pixel font is already bold */
            user-select: none;
            -webkit-user-select: none;
            text-shadow: 1px 1px 0px var(--arcade-white);
            box-shadow: 0 0 8px var(--arcade-cyan);
            display: flex; /* Center text */
            justify-content: center;
            align-items: center;
            text-transform: uppercase;
        }
        #jumpButton:active {
            background-color: rgba(255, 255, 0, 0.8); /* Yellow when pressed */
            border-color: var(--arcade-yellow);
            color: var(--arcade-black);
            box-shadow: 0 0 10px var(--arcade-yellow);
        }

        /* --- Utility & Orientation --- */
        .hidden { display: none !important; }
        #orientationMessage {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: var(--arcade-black);
            color: var(--arcade-white);
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            font-family: var(--font-pixel);
            padding: 20px;
            line-height: 1.8;
            font-size: 1.2em;
            text-transform: uppercase;
        }
        #orientationMessage p { margin-bottom: 1em; text-shadow: var(--text-shadow); }

        /* --- Media Queries for Orientation and Controls --- */
        @media (orientation: portrait) {
            #game-container { display: none; }
            #orientationMessage { display: flex; }
            #joystickContainer, #jumpButton { display: none !important; }
        }
        @media (orientation: landscape) {
            #orientationMessage { display: none; }
            #game-container { display: block; }
             /* Show controls only on touch devices in landscape */
             @media (hover: none) and (pointer: coarse) {
                 #joystickContainer { display: block; }
                 #jumpButton { display: flex; } /* Use flex to center text */
             }
             /* Hide controls on non-touch devices (desktops) */
             @media (hover: hover) and (pointer: fine) {
                 #joystickContainer { display: none; }
                 #jumpButton { display: none; }
             }
        }

    </style>
</head>
<body>
    <div id="orientationMessage"><p>Please rotate your device to landscape mode to play.</p><p>Bitte drehe dein Gerät ins Querformat, um zu spielen.</p></div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <img id="knightImage" src="" alt="Knight"> <div id="poiInfoOverlay" class="poi-overlay">
            <h3 id="poiName">POI Name</h3>
            <p id="poiInfoText">POI information will appear here.</p>
            <button id="closePoiButton">Close</button>
        </div>

        <div id="startScreen" class="ui-screen">
            <h1>RitterRun</h1>
            <p>Explore Bad Belzig!</p>
            <p>High Score: <span id="startHighScore">0</span></p>
            <button id="startButton" class="ui-button">Start Game</button>
            <p class="instructions">Arrows/Joystick: Move | Space/Tap: Jump<br>Enter/Tap POI: Close Info</p>
        </div>

        <div id="gameOverScreen" class="ui-screen hidden">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p>Score/Punkte: <span id="finalScore">0</span></p>
            <p>High Score: <span id="gameOverHighScore">0</span></p>
            <button id="restartButton" class="ui-button">Restart</button>
        </div>

        <div id="scoreDisplay" class="hidden">Score: <span id="currentScore">0</span></div>
        <div id="livesDisplay" class="hidden">Lives: <span id="currentLives">5</span></div>
    </div>

    <div id="joystickContainer"><div id="joystickBase"><div id="joystickKnob"></div></div></div>
    <button id="jumpButton">JUMP</button>

    <script>
        // --- Strict mode and IIFE ---
        (function() {
            'use strict';

            // --- DOM Element References ---
            const canvas = document.getElementById('gameCanvas');
            const gameContainer = document.getElementById('game-container');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const currentScoreSpan = document.getElementById('currentScore');
            const finalScoreSpan = document.getElementById('finalScore');
            const startHighScoreSpan = document.getElementById('startHighScore');
            const gameOverHighScoreSpan = document.getElementById('gameOverHighScore');
            const poiOverlay = document.getElementById('poiInfoOverlay');
            const poiNameEl = document.getElementById('poiName');
            const poiInfoTextEl = document.getElementById('poiInfoText');
            const closePoiButton = document.getElementById('closePoiButton');
            const livesDisplay = document.getElementById('livesDisplay');
            const currentLivesSpan = document.getElementById('currentLives');
            const knightImageEl = document.getElementById('knightImage');
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            const jumpButton = document.getElementById('jumpButton');
            const orientationMessage = document.getElementById('orientationMessage');
            const gameOverTitle = document.getElementById('gameOverTitle'); // Get the Game Over title element

            // --- Canvas and Context ---
            let ctx; let canvasWidth; let canvasHeight;

            // --- Essential Element Check ---
            if (!canvas || !canvas.getContext || !gameContainer) { alert("Fatal Error: Canvas not found!"); return; }
            ctx = canvas.getContext('2d');
            const requiredElements = { startScreen, gameOverScreen, startButton, restartButton, scoreDisplay, currentScoreSpan, finalScoreSpan, startHighScoreSpan, gameOverHighScoreSpan, poiOverlay, poiNameEl, poiInfoTextEl, closePoiButton, livesDisplay, currentLivesSpan, knightImageEl, joystickContainer, joystickBase, joystickKnob, jumpButton, orientationMessage, gameOverTitle };
            for (const key in requiredElements) { if (!requiredElements[key]) { console.error(`Fatal Error: UI element '${key}' not found!`); alert(`Fatal Error: UI element missing (${key})!`); return; } }

            // --- Game States ---
            const GameState = Object.freeze({ MENU: 'MENU', PLAYING: 'PLAYING', GAME_OVER: 'GAME_OVER', LOADING: 'LOADING' });
            let currentGameState = GameState.LOADING;

            // --- Collision Types ---
            const CollisionType = Object.freeze({ NONE: 0, TOP: 1, SIDE: 2 });

            // --- Game Constants (Mostly unchanged, but check if adjustments needed for new feel) ---
            const LIVES_START_COUNT = 3; // Fewer lives for arcade feel?
            const INVINCIBILITY_DURATION_MS = 1500; // Slightly longer flicker
            const GROUND_HEIGHT_PERCENT = 0.1; // Slightly thicker ground
            const PLAYER_INITIAL_X_PERCENT = 0.1; // Start closer to edge
             // Player size might need tweaking based on sprite
            const PLAYER_WIDTH_PERCENT_DESKTOP = 0.10;
            const PLAYER_HEIGHT_PERCENT_DESKTOP = 0.20;
            const PLAYER_WIDTH_PERCENT_MOBILE = 0.14;
            const PLAYER_HEIGHT_PERCENT_MOBILE = 0.28;
            const PLAYER_GRAVITY_FACTOR = 1200; // Slightly faster fall?
            const PLAYER_JUMP_FACTOR = -45; // Slightly higher jump?
            const PLAYER_BOUNCE_POWER_MULTIPLIER = 0.8;
            const PLAYER_ACCEL_FACTOR = 1.2; // Faster acceleration?
            const PLAYER_MAX_DX_FACTOR = 0.45; // Faster max speed?
            const PLAYER_FRICTION = 0.92; // Less friction?
            // Obstacle sizes remain percentage-based
            const OBSTACLE_STONE_WIDTH_PERCENT = 0.088;
            const OBSTACLE_STONE_HEIGHT_PERCENT = 0.176;
            const OBSTACLE_TRACTOR_WIDTH_PERCENT = 0.176;
            const OBSTACLE_TRACTOR_HEIGHT_PERCENT = 0.226;
            const OBSTACLE_FAMILY_WIDTH_PERCENT = 0.088;
            const OBSTACLE_FAMILY_HEIGHT_PERCENT = 0.176;
            const POI_SIGN_WIDTH_PERCENT = 0.226; // Keep doubled size
            const POI_SIGN_HEIGHT_PERCENT = 0.55;  // Keep doubled size
            const OBSTACLE_SPEED_FACTOR = 0.45; // Faster base speed
            const SPEED_INCREASE_INTERVAL_SCORE = 300; // Increase speed more often
            const BACKGROUND_SWITCH_SCORE_INTERVAL = 1000; // Keep background switching
            const POI_SPAWN_CHANCE = 0.15;
            const OBSTACLE_BASE_SPAWN_TIME_MS = 1500; // Spawn slightly faster
            const OBSTACLE_MIN_SPAWN_TIME_MS = 700; // Faster minimum spawn
            const COLLISION_LANDING_TOLERANCE_FACTOR = 0.05; // Slightly more forgiving landing
            const MOBILE_BREAKPOINT_WIDTH = 850;
            const BACKGROUND_SCROLL_SPEED_FACTOR = 0.15; // Faster background scroll
            const backgroundSequence = [0, 1, 2, 1, 0]; // Keep sequence
            const FINAL_POI_ID = 7;
            const BACKGROUND_TRANSITION_DURATION = 800; // Faster transition
            const JOYSTICK_DEAD_ZONE = 10;
            const TRACTOR_OSC_AMPLITUDE_FACTOR = 0.02;
            const TRACTOR_OSC_FREQUENCY = 0.75;

            // --- Game Variables ---
            let score = 0; let highScore = 0; let playerLives = LIVES_START_COUNT; let playerInvincibleUntil = 0;
            let player = { x: 0, y: 0, width: 0, height: 0, dx: 0, dy: 0, gravity: 0, jumpPower: 0, grounded: true };
            let obstacles = []; let obstacleSpeed = 0; let playerMaxDx = 0; let playerAccel = 0;
            let nextSpeedIncreaseScore = SPEED_INCREASE_INTERVAL_SCORE; let bgX = 0; let backgroundSequenceIndex = 0; let nextBackgroundSwitchScore = BACKGROUND_SWITCH_SCORE_INTERVAL;
            let nextObstacleSpawnTime = 0; let nextPoiIndex = 0; let lastTime = 0; let gameInitialized = false; let isPaused = false; let groundHeightPx = 0; let collisionLandingTolerancePx = 0;
            let currentKnightVisualState = null; let isPressingLeft = false; let isPressingRight = false;
            let isTransitioningBackground = false; let transitionStartTime = 0; let previousBackgroundSequenceIndex = 0;
            let joystickActive = false; let joystickStartX = 0; let joystickStartY = 0; let joystickBaseRect = null; let joystickRadius = 0;

            // --- Graphics Assets (Paths remain the same, ensure assets exist) ---
             const assets = {
                 knight_run: { img: new Image(), loaded: false, src: 'assets/knight_run.gif' },
                 knight_jump: { img: new Image(), loaded: false, src: 'assets/knight_jump.png' },
                 stone: { img: new Image(), loaded: false, src: 'assets/stone.png' },
                 tractor: { img: new Image(), loaded: false, src: 'assets/tractor.png' },
                 family: { img: new Image(), loaded: false, src: 'assets/family.png' },
                 background1: { img: new Image(), loaded: false, src: 'assets/background1.png' },
                 background2: { img: new Image(), loaded: false, src: 'assets/background2.png' },
                 background3: { img: new Image(), loaded: false, src: 'assets/background3.png' },
                 // POI Images
                 therme: { img: new Image(), loaded: false, src: 'assets/therme.png' },
                 freibad: { img: new Image(), loaded: false, src: 'assets/freibad.png' },
                 kulturzentrum: { img: new Image(), loaded: false, src: 'assets/kulturzentrum.png' },
                 bahnhof: { img: new Image(), loaded: false, src: 'assets/bahnhof.png' },
                 post: { img: new Image(), loaded: false, src: 'assets/post.png' },
                 rathaus: { img: new Image(), loaded: false, src: 'assets/rathaus.png' },
                 burg: { img: new Image(), loaded: false, src: 'assets/burg.png' }
             };
             let assetsLoadedCount = 0; let totalAssets = Object.keys(assets).length; let allAssetsLoaded = false;

            // --- Obstacle/POI Definitions ---
            const regularObstacleTypes = [ { assetKey: 'stone', widthPercent: OBSTACLE_STONE_WIDTH_PERCENT, heightPercent: OBSTACLE_STONE_HEIGHT_PERCENT }, { assetKey: 'tractor', widthPercent: OBSTACLE_TRACTOR_WIDTH_PERCENT, heightPercent: OBSTACLE_TRACTOR_HEIGHT_PERCENT }, { assetKey: 'family', widthPercent: OBSTACLE_FAMILY_WIDTH_PERCENT, heightPercent: OBSTACLE_FAMILY_HEIGHT_PERCENT } ];
            const poiSignDimensions = { widthPercent: POI_SIGN_WIDTH_PERCENT, heightPercent: POI_SIGN_HEIGHT_PERCENT };

            // --- POI Data (Unchanged) ---
             const poiData = [
                 { id: 1, name: "SteinTherme", info: "Known for its unique thermal saltwater pools and health benefits. | Bekannt für ihre einzigartigen Thermalsolebecken und Gesundheitsvorteile.", assetKey: 'therme' },
                 { id: 2, name: "Freibad", info: "The popular outdoor swimming pool, perfect for summer days. | Das beliebte Freibad, perfekt für Sommertage.", assetKey: 'freibad' },
                 { id: 3, name: "Kulturzentrum & Bibliothek", info: "A cultural hub with its distinctive red-brick facade and arched windows. | Ein kultureller Mittelpunkt mit markanter roter Backsteinfassade und Bogenfenstern.", assetKey: 'kulturzentrum' },
                 { id: 4, name: "Fläming Bahnhof", info: "The local train station connecting Bad Belzig to the region. | Der lokale Bahnhof, der Bad Belzig mit der Region verbindet.", assetKey: 'bahnhof' },
                 { id: 5, name: "Postmeilensäule", info: "A historic post mile marker showing distances on old postal routes. | Ein historischer Postmeilenstein, der Entfernungen auf alten Postrouten anzeigt.", assetKey: 'post' },
                 { id: 6, name: "Rathaus & Tourist-Information", info: "The town hall, center of local government and visitor information. | Rathaus, Zentrum der Kommunalverwaltung und Besucherinformation.", assetKey: 'rathaus' },
                 { id: 7, name: "Burg Eisenhardt", info: "Well-preserved medieval castle, vital to the region's history and defense. | Gut erhaltene mittelalterliche Burg, entscheidend für die Geschichte und Verteidigung der Region.", assetKey: 'burg' }
             ];

            // --- Asset Loading Functions (Unchanged) ---
            function assetLoaded(assetKey) { console.log(`Asset loaded: ${assetKey}`); assets[assetKey].loaded = true; assetsLoadedCount++; if (assetsLoadedCount === totalAssets) { console.log("All assets loaded."); allAssetsLoaded = true; if (currentGameState === GameState.LOADING) { initGame(); } } }
            function assetLoadError(assetKey, event) { console.error(`Failed to load asset: ${assets[assetKey].src}. Check path and file existence. Event:`, event); alert(`Error loading image: ${assets[assetKey].src}\nGame might not display correctly.`); assetsLoadedCount++; if (assetsLoadedCount === totalAssets) { console.warn("Finished loading assets, but some failed."); allAssetsLoaded = true; if (currentGameState === GameState.LOADING) { initGame(); } } }
            function loadAssets() { console.log("Starting asset loading..."); currentGameState = GameState.LOADING; for (const key in assets) { if (Object.prototype.hasOwnProperty.call(assets, key) && assets[key].img) { assets[key].img.src = assets[key].src; assets[key].img.onload = () => assetLoaded(key); assets[key].img.onerror = (e) => assetLoadError(key, e); } } }

            // --- High Score Handling (Unchanged) ---
            function loadHighScore() { try { const savedScore = localStorage.getItem('ritterRunHighScore'); highScore = savedScore ? parseInt(savedScore, 10) : 0; if (isNaN(highScore)) highScore = 0; startHighScoreSpan.textContent = highScore; gameOverHighScoreSpan.textContent = highScore; } catch (e) { console.error("LS Error Load HS:", e); highScore = 0; } }
            function saveHighScore() { if (score > highScore) { highScore = score; try { localStorage.setItem('ritterRunHighScore', highScore.toString()); gameOverHighScoreSpan.textContent = highScore; } catch (e) { console.error("LS Error Save HS:", e); } } }

            // --- Sound Playing Helper (Stub - consider adding retro sounds!) ---
            function playSound(soundId) {
                // TODO: Implement actual retro sound effects using Web Audio API or a library
                console.log(`Playing sound: ${soundId}`);
                // Example sounds needed: 'start', 'jump', 'hit', 'bounce', 'poi', 'win', 'gameover'
            }

            // --- Reset Game Variables (Adjusted for new constants) ---
            function resetGame() {
                score = 0; playerLives = LIVES_START_COUNT; playerInvincibleUntil = 0; obstacles = [];
                groundHeightPx = canvasHeight * GROUND_HEIGHT_PERCENT;
                collisionLandingTolerancePx = canvasHeight * COLLISION_LANDING_TOLERANCE_FACTOR;
                // Speeds and forces are now calculated based on potentially updated factors
                obstacleSpeed = canvasWidth * OBSTACLE_SPEED_FACTOR;
                playerMaxDx = canvasWidth * PLAYER_MAX_DX_FACTOR;
                playerAccel = canvasWidth * PLAYER_ACCEL_FACTOR;
                player.gravity = canvasHeight / PLAYER_GRAVITY_FACTOR;
                player.jumpPower = canvasHeight / PLAYER_JUMP_FACTOR;

                // Player size set in resizeCanvas based on mobile check
                resizeCanvas(); // Call resize to set initial player size correctly

                player.x = canvasWidth * PLAYER_INITIAL_X_PERCENT;
                player.y = canvasHeight - groundHeightPx - player.height; // Y depends on height, set by resize
                player.dx = 0; player.dy = 0; player.grounded = true;

                nextSpeedIncreaseScore = SPEED_INCREASE_INTERVAL_SCORE;
                bgX = 0; backgroundSequenceIndex = 0; nextBackgroundSwitchScore = BACKGROUND_SWITCH_SCORE_INTERVAL;
                currentScoreSpan.textContent = score; currentLivesSpan.textContent = playerLives; nextObstacleSpawnTime = 0; nextPoiIndex = 0; isPaused = false; isPressingLeft = false; isPressingRight = false;
                poiOverlay.classList.remove('visible'); knightImageEl.style.display = 'none'; currentKnightVisualState = null;
                isTransitioningBackground = false; transitionStartTime = 0; previousBackgroundSequenceIndex = 0;
                joystickActive = false; if(joystickKnob) joystickKnob.style.transform = 'translate(-50%, -50%)';

                // Reset Game Over title text and style
                gameOverTitle.textContent = "Game Over!";
                gameOverTitle.classList.remove('win-title'); // Remove win class if it was there

                console.log(`Game Reset - Obstacle Speed: ${obstacleSpeed.toFixed(1)}`);
            }

            // --- Update Functions ---
            function updatePlayer(dt) {
                 // Apply friction first if no input
                 if (!isPressingLeft && !isPressingRight) {
                     player.dx *= PLAYER_FRICTION;
                     if (Math.abs(player.dx) < 0.5) { // Stop if slow enough
                         player.dx = 0;
                     }
                 }
                 // Apply acceleration based on input
                 if (isPressingLeft) {
                     player.dx -= playerAccel * dt;
                 } else if (isPressingRight) {
                     player.dx += playerAccel * dt;
                 }

                 // Clamp speed
                 player.dx = Math.max(-playerMaxDx, Math.min(playerMaxDx, player.dx));

                 // Update position
                 player.x += player.dx * dt;

                 // Wall collision
                 if (player.x < 0) {
                     player.x = 0; player.dx = 0;
                 }
                 if (player.x + player.width > canvasWidth) {
                     player.x = canvasWidth - player.width; player.dx = 0;
                 }

                 // Vertical movement (Gravity and Jump)
                 if (!player.grounded) {
                     player.dy += player.gravity * dt * 60; // Apply gravity (scaled by dt)
                     player.y += player.dy * dt; // Apply vertical velocity
                 }

                 // Ground collision
                 const groundLevel = canvasHeight - groundHeightPx - player.height;
                 if (player.y >= groundLevel) {
                     player.y = groundLevel;
                     player.dy = 0;
                     if (!player.grounded) {
                         // playSound('land'); // Optional landing sound
                         player.grounded = true;
                     }
                 }
             }
            function updateObstacles(dt, currentTime) {
                 // --- Spawn Logic (Mostly Unchanged) ---
                 if (currentTime >= nextObstacleSpawnTime) {
                     let newObjectData = null;
                     const anyPoiAssetLoaded = poiData.some(poi => assets[poi.assetKey]?.loaded);
                     const willSpawnPOI = Math.random() < POI_SPAWN_CHANCE;
                     const canSpawnPOI = nextPoiIndex < poiData.length && anyPoiAssetLoaded;
                     const spawnPOI = willSpawnPOI && canSpawnPOI;

                     if (spawnPOI) {
                         const poi = poiData[nextPoiIndex];
                         if (assets[poi.assetKey] && assets[poi.assetKey].loaded) {
                             const objWidth = canvasWidth * poiSignDimensions.widthPercent;
                             const objHeight = canvasHeight * poiSignDimensions.heightPercent;
                             newObjectData = { isPOI: true, poiId: poi.id, passed: false, x: canvasWidth, baseX: canvasWidth, y: canvasHeight - groundHeightPx - objHeight, width: objWidth, height: objHeight, assetKey: poi.assetKey };
                             console.log(`DEBUG: Spawning POI (ID: ${poi.id}, Asset: ${poi.assetKey})`);
                             nextPoiIndex++;
                         } else {
                              console.warn(`Skipping POI spawn for ID ${poi.id} because asset '${poi.assetKey}' is not loaded.`);
                         }
                     } else {
                         // Spawn regular obstacle
                         if (regularObstacleTypes.length > 0) {
                             const typeIndex = Math.floor(Math.random() * regularObstacleTypes.length);
                             const type = regularObstacleTypes[typeIndex];
                             if (assets[type.assetKey] && assets[type.assetKey].loaded) {
                                 const objWidth = canvasWidth * type.widthPercent;
                                 const objHeight = canvasHeight * type.heightPercent;
                                 newObjectData = { isPOI: false, x: canvasWidth, baseX: canvasWidth, y: canvasHeight - groundHeightPx - objHeight, width: objWidth, height: objHeight, assetKey: type.assetKey, isKnocked: false };
                                 if (type.assetKey === 'tractor') {
                                     newObjectData.isOscillating = true;
                                     newObjectData.oscillationPhase = Math.random() * Math.PI * 2;
                                 }
                             }
                         }
                     }

                     if (newObjectData) {
                         obstacles.push(newObjectData);
                     }
                     // Use updated spawn time constants
                     const spawnTimeVariance = 400; // Adjust variance if needed
                     const nextSpawnDelay = OBSTACLE_BASE_SPAWN_TIME_MS + (Math.random() * spawnTimeVariance - spawnTimeVariance / 2);
                     nextObstacleSpawnTime = currentTime + Math.max(OBSTACLE_MIN_SPAWN_TIME_MS, nextSpawnDelay);
                 }

                 // --- Movement & Update Logic (Unchanged logic, uses updated obstacleSpeed) ---
                 const movement = obstacleSpeed * dt;
                 for (let i = obstacles.length - 1; i >= 0; i--) {
                     const obj = obstacles[i];
                     if (obj.isKnocked) {
                         obj.y += (canvasHeight * 1.5) * dt; // Fall faster when knocked
                     } else {
                         if (obj.baseX === undefined) obj.baseX = obj.x;
                         obj.baseX -= movement;
                         if (obj.assetKey === 'tractor') {
                             obj.oscillationPhase += TRACTOR_OSC_FREQUENCY * 2 * Math.PI * dt;
                             const amplitudePx = canvasWidth * TRACTOR_OSC_AMPLITUDE_FACTOR;
                             const xOffset = amplitudePx * Math.sin(obj.oscillationPhase);
                             obj.x = obj.baseX + xOffset;
                         } else {
                             obj.x = obj.baseX;
                         }
                     }

                     // POI Trigger Check
                     if (obj.isPOI && !obj.passed) {
                         const triggerPoint = obj.x; // Trigger when player's *front* passes the object's front
                         if (player.x > triggerPoint) { // Simpler trigger check
                             console.log(`>>> POI TRIGGERED! ID: ${obj.poiId}`);
                             obj.passed = true;
                             score += 50; // POI Score Bonus
                             currentScoreSpan.textContent = score;
                             playSound('poi');
                             if (obj.poiId === FINAL_POI_ID) {
                                 console.log(">>> GAME WON! Reached Burg Eisenhardt!");
                                 playSound('win');
                                 currentGameState = GameState.GAME_OVER;
                                 saveHighScore();
                                 // Set win title and class
                                 gameOverTitle.textContent = "Burg Reached!";
                                 gameOverTitle.classList.add('win-title');
                                 finalScoreSpan.textContent = score;
                                 gameOverHighScoreSpan.textContent = highScore; // Ensure high score is updated here too
                                 gameOverScreen.classList.remove('hidden');
                                 scoreDisplay.classList.add('hidden');
                                 livesDisplay.classList.add('hidden');
                                 knightImageEl.style.display = 'none';
                                 if (poiOverlay.classList.contains('visible')) { closePoiOverlay(); }
                             } else {
                                 console.log(">>> Calling displayPOIInfo for regular POI.");
                                 displayPOIInfo(obj.poiId);
                             }
                         }
                     }
                     // Off-screen check
                     if (obj.x + obj.width < -150 || obj.y > canvasHeight + obj.height + 100) { // Wider removal threshold
                         obstacles.splice(i, 1);
                     }
                 }
             }
            function checkCollisions() {
                 const now = performance.now();
                 if (now < playerInvincibleUntil) { return { type: CollisionType.NONE }; } // Player is invincible

                 // Slightly tighter player hitbox for arcade feel
                 const hitboxInsetX = player.width * 0.15;
                 const hitboxInsetY = player.height * 0.15;
                 const playerRect = {
                     x: player.x + hitboxInsetX,
                     y: player.y + hitboxInsetY,
                     width: player.width - 2 * hitboxInsetX,
                     height: player.height - 2 * hitboxInsetY,
                     bottom: player.y + player.height - hitboxInsetY, // Use adjusted bottom
                     right: player.x + player.width - hitboxInsetX,   // Use adjusted right
                     top: player.y + hitboxInsetY // Explicit top for clarity
                 };

                 for (const obstacle of obstacles) {
                     if (obstacle.isPOI || obstacle.isKnocked) { continue; } // Ignore POIs and knocked obstacles

                     // Slightly tighter obstacle hitbox
                     const obsHitboxInsetX = obstacle.width * 0.1;
                     const obsHitboxInsetY = obstacle.height * 0.1;
                     const obstacleRect = {
                         x: obstacle.x + obsHitboxInsetX,
                         y: obstacle.y + obsHitboxInsetY,
                         width: obstacle.width - 2 * obsHitboxInsetX,
                         height: obstacle.height - 2 * obsHitboxInsetY,
                         top: obstacle.y + obsHitboxInsetY, // Explicit top
                         right: obstacle.x + obstacle.width - obsHitboxInsetX // Explicit right
                     };

                     // Standard AABB collision check
                     if (playerRect.x < obstacleRect.right &&
                         playerRect.right > obstacleRect.x &&
                         playerRect.y < obstacleRect.y + obstacleRect.height && // Check against full height bottom
                         playerRect.bottom > obstacleRect.top) {                // Check against adjusted top

                         const isFalling = player.dy > 0; // Check if player has downward velocity
                         // Landing check: Player's adjusted bottom is near the obstacle's adjusted top, and player is falling
                         const landedOnTop = isFalling &&
                                             playerRect.bottom >= obstacleRect.top &&
                                             playerRect.bottom <= obstacleRect.top + collisionLandingTolerancePx;

                         if (landedOnTop) {
                             console.log(`Collision: TOP on ${obstacle.assetKey}`);
                             return { type: CollisionType.TOP, obstacle: obstacle };
                         } else {
                             // Any other overlap is considered a side collision
                             console.warn(`Collision: SIDE with ${obstacle.assetKey}`);
                             return { type: CollisionType.SIDE };
                         }
                     }
                 }
                 return { type: CollisionType.NONE }; // No collision detected
             }
            function updateScoreAndSpeed(dt) {
                 // Increase score based on time/distance (multiplied by speed factor)
                 score += Math.round(1 + (obstacleSpeed / (canvasWidth * OBSTACLE_SPEED_FACTOR)) * 2) * dt * 10; // More points for higher speed
                 currentScoreSpan.textContent = Math.floor(score); // Display integer score

                 // Speed Increase Logic (Unchanged logic, uses updated constants)
                 if (score >= nextSpeedIncreaseScore) {
                     const speedIncreaseFactor = 1.05; // Increase speed by 5%
                     obstacleSpeed *= speedIncreaseFactor;
                     // Optionally increase player speed cap too?
                     // playerMaxDx *= speedIncreaseFactor;
                     // playerAccel *= speedIncreaseFactor;
                     nextSpeedIncreaseScore += SPEED_INCREASE_INTERVAL_SCORE;
                     console.log(`Speed increased! New obstacle speed: ${obstacleSpeed.toFixed(1)}`);
                     // Adjust spawn times based on new speed?
                     // OBSTACLE_BASE_SPAWN_TIME_MS = Math.max(OBSTACLE_MIN_SPAWN_TIME_MS, OBSTACLE_BASE_SPAWN_TIME_MS * 0.98);
                 }

                 // Background Transition Logic (Unchanged logic, uses updated constants)
                 if (!isTransitioningBackground && score >= nextBackgroundSwitchScore) {
                     previousBackgroundSequenceIndex = backgroundSequenceIndex;
                     backgroundSequenceIndex = (backgroundSequenceIndex + 1) % backgroundSequence.length;
                     if (previousBackgroundSequenceIndex !== backgroundSequenceIndex) {
                         isTransitioningBackground = true;
                         transitionStartTime = performance.now();
                         console.log(`Background transition START: ${previousBackgroundSequenceIndex} -> ${backgroundSequenceIndex}`);
                     }
                     nextBackgroundSwitchScore += BACKGROUND_SWITCH_SCORE_INTERVAL;
                 }
             }

            // --- Draw Functions ---
            function drawBackground(dt) {
                 const now = performance.now();
                 const bgMovement = isPaused ? 0 : obstacleSpeed * BACKGROUND_SCROLL_SPEED_FACTOR * dt;
                 bgX -= bgMovement;
                 if (bgX <= -canvasWidth) { bgX += canvasWidth; }

                 // --- Outrun Sky Gradient ---
                 const skyGradient = ctx.createLinearGradient(0, 0, 0, canvasHeight * 0.6); // Gradient covers top 60%
                 skyGradient.addColorStop(0, '#FF69B4');    // Pink/Orange at the top
                 skyGradient.addColorStop(0.5, '#FFA500');  // Orange midpoint
                 skyGradient.addColorStop(1, '#0077FF');    // Blue towards horizon
                 ctx.fillStyle = skyGradient;
                 ctx.fillRect(0, 0, canvasWidth, canvasHeight * 0.9); // Fill most of the canvas (below ground)

                 // --- Draw Scrolling Background Images (Optional, keep if desired) ---
                 ctx.globalAlpha = 0.6; // Make background images slightly transparent
                 let currentAssetKey = '';
                 if (isTransitioningBackground) {
                     const elapsed = now - transitionStartTime;
                     const progress = Math.min(1, elapsed / BACKGROUND_TRANSITION_DURATION);
                     const oldActualIndex = backgroundSequence[previousBackgroundSequenceIndex];
                     const oldAssetKey = `background${oldActualIndex + 1}`;
                     const oldAsset = assets[oldAssetKey];
                     const newActualIndex = backgroundSequence[backgroundSequenceIndex];
                     const newAssetKey = `background${newActualIndex + 1}`;
                     const newAsset = assets[newAssetKey];

                     if (oldAsset && oldAsset.loaded) {
                         ctx.globalAlpha = (1 - progress) * 0.6; // Fade out old background
                         ctx.drawImage(oldAsset.img, bgX, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8); // Draw lower on screen
                         ctx.drawImage(oldAsset.img, bgX + canvasWidth, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8);
                     }
                     if (newAsset && newAsset.loaded) {
                         ctx.globalAlpha = progress * 0.6; // Fade in new background
                         ctx.drawImage(newAsset.img, bgX, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8);
                         ctx.drawImage(newAsset.img, bgX + canvasWidth, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8);
                         currentAssetKey = newAssetKey;
                     }
                     if (progress >= 1) { isTransitioningBackground = false; console.log("Background transition END"); }
                 } else {
                     const actualBackgroundIndex = backgroundSequence[backgroundSequenceIndex];
                     currentAssetKey = `background${actualBackgroundIndex + 1}`;
                     const currentAsset = assets[currentAssetKey];
                     if (currentAsset && currentAsset.loaded) {
                         ctx.globalAlpha = 0.6; // Apply transparency
                         ctx.drawImage(currentAsset.img, bgX, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8);
                         ctx.drawImage(currentAsset.img, bgX + canvasWidth, canvasHeight * 0.1, canvasWidth, canvasHeight * 0.8);
                     }
                 }
                 ctx.globalAlpha = 1.0; // Reset global alpha

                 // --- Draw Ground ---
                 const groundLevelY = canvasHeight - groundHeightPx;
                 ctx.fillStyle = '#333'; // Dark asphalt color
                 ctx.fillRect(0, groundLevelY, canvasWidth, groundHeightPx);

                 // Optional: Add simple road lines for perspective illusion
                 ctx.strokeStyle = '#888'; // Grey lines
                 ctx.lineWidth = 2;
                 const numLines = 5;
                 for (let i = 0; i < numLines; i++) {
                     const lineY = groundLevelY + (groundHeightPx / numLines) * i;
                     const perspectiveWidth = canvasWidth * (0.1 + 0.9 * (i / numLines)); // Lines get wider closer
                     const startX = (canvasWidth - perspectiveWidth) / 2;
                     // Dashed lines effect
                     ctx.beginPath();
                     ctx.setLineDash([15, 10]); // Adjust dash pattern
                     ctx.moveTo(startX, lineY);
                     ctx.lineTo(startX + perspectiveWidth, lineY);
                     ctx.stroke();
                     ctx.setLineDash([]); // Reset dash pattern
                 }
             }
            function drawObstacles() {
                 for (const obj of obstacles) {
                     if (assets[obj.assetKey] && assets[obj.assetKey].loaded) {
                         // Optional: Add a simple black outline for better visibility
                         ctx.shadowColor = 'black';
                         ctx.shadowBlur = 0;
                         ctx.shadowOffsetX = 1;
                         ctx.shadowOffsetY = 1;
                         ctx.drawImage(assets[obj.assetKey].img, obj.x, obj.y, obj.width, obj.height);
                         // Reset shadow
                         ctx.shadowColor = 'transparent';
                     } else {
                         // Fallback drawing
                         ctx.fillStyle = obj.isPOI ? 'blue' : 'red';
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                         console.warn("Attempted to draw obstacle/POI but asset not loaded:", obj.assetKey);
                     }
                 }
             }
            function updateKnightVisuals() {
                const now = performance.now();
                let targetState = player.grounded ? 'run' : 'jump';
                let targetSrc = player.grounded ? assets.knight_run.src : assets.knight_jump.src;

                // Ensure the correct image is loaded and set
                if (targetState !== currentKnightVisualState || knightImageEl.src !== targetSrc) {
                    if ((targetState === 'run' && assets.knight_run.loaded) || (targetState === 'jump' && assets.knight_jump.loaded)) {
                        if (knightImageEl.src !== targetSrc) {
                            knightImageEl.src = targetSrc;
                            console.log(`Set knight visual state to: ${targetState}`);
                        }
                        currentKnightVisualState = targetState;
                    } else {
                        // If the required asset isn't loaded yet, don't change the src
                        // console.warn(`Asset for state ${targetState} not loaded yet.`);
                    }
                }

                // Invincibility flashing
                let currentOpacity = 1;
                if (now < playerInvincibleUntil) {
                    // Faster flashing for arcade feel
                    if (Math.floor(now / 80) % 2 !== 0) {
                        currentOpacity = 0.3;
                    }
                }
                knightImageEl.style.opacity = currentOpacity;

                // Update position and size
                knightImageEl.style.left = `${player.x}px`;
                knightImageEl.style.top = `${player.y}px`;
                knightImageEl.style.width = `${player.width}px`;
                knightImageEl.style.height = `${player.height}px`;

                // Ensure visibility during gameplay
                if (currentGameState === GameState.PLAYING) {
                     if (knightImageEl.style.display === 'none') {
                         knightImageEl.style.display = 'block';
                     }
                 } else {
                     // Hide during Menu/Game Over/Loading
                     if (knightImageEl.style.display !== 'none') {
                         knightImageEl.style.display = 'none';
                     }
                 }
            }

            // --- displayPOIInfo & closePoiOverlay (Unchanged logic, styling handled by CSS) ---
            function displayPOIInfo(poiId) {
                console.log(">>> Entered displayPOIInfo. Pausing game.");
                const poi = poiData.find(p => p.id === poiId);
                if (!poi) { console.warn(`POI data not found for ID: ${poiId}`); return; }
                isPaused = true; // Pause the game logic
                poiNameEl.textContent = poi.name;
                const infoParts = poi.info.split('|').map(s => s.trim());
                const formattedInfo = infoParts.join('<br><br>'); // Keep line breaks
                poiInfoTextEl.innerHTML = formattedInfo;
                poiOverlay.classList.add('visible');
                console.log(">>> Added 'visible' class to poiOverlay. displayPOIInfo finished.");
            }
            function closePoiOverlay() {
                // Only close if it's actually visible and the game is paused
                if (poiOverlay.classList.contains('visible') && isPaused) {
                    console.log(">>> Entered closePoiOverlay. Removing visible class, resuming game.");
                    poiOverlay.classList.remove('visible');
                    isPaused = false; // Resume game logic
                    lastTime = performance.now(); // Reset timer to avoid large dt jump
                    console.log(">>> Closed POI Overlay. Game RESUMED.");
                } else {
                     console.log(">>> closePoiOverlay called but overlay not visible or game not paused.");
                }
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                 const dt = isPaused ? 0 : (timestamp - lastTime) / 1000 || 0; // Calculate dt only if not paused
                 if (!isPaused) { lastTime = timestamp; } // Update lastTime only if not paused

                 if (currentGameState === GameState.PLAYING && !isPaused) {
                     let collisionHandledThisFrame = false;
                     const collisionResult = checkCollisions();

                     if (collisionResult.type === CollisionType.SIDE) {
                         playSound('hit');
                         playerLives--;
                         currentLivesSpan.textContent = playerLives;
                         collisionHandledThisFrame = true; // Collision handled

                         if (playerLives > 0) {
                             console.log(`Life lost! ${playerLives} remaining.`);
                             // Reset player state slightly after hit
                             player.y = canvasHeight - groundHeightPx - player.height;
                             player.dy = 0;
                             player.dx *= 0.5; // Lose some horizontal speed
                             player.grounded = true;
                             playerInvincibleUntil = performance.now() + INVINCIBILITY_DURATION_MS;
                             console.log(`Player invincible until ${playerInvincibleUntil.toFixed(0)}`);
                         } else {
                             console.warn("GAME OVER - No lives left.");
                             playSound('gameover');
                             currentGameState = GameState.GAME_OVER;
                             saveHighScore();
                             finalScoreSpan.textContent = Math.floor(score); // Show final score
                             gameOverHighScoreSpan.textContent = highScore; // Ensure high score shown
                             // Reset title text/class for standard game over
                             gameOverTitle.textContent = "Game Over!";
                             gameOverTitle.classList.remove('win-title');
                             gameOverScreen.classList.remove('hidden');
                             scoreDisplay.classList.add('hidden');
                             livesDisplay.classList.add('hidden');
                             knightImageEl.style.display = 'none';
                             if (poiOverlay.classList.contains('visible')) { closePoiOverlay(); }
                         }
                     } else if (collisionResult.type === CollisionType.TOP) {
                         // Bounce off obstacle
                         player.y = collisionResult.obstacle.y - player.height; // Place player on top
                         player.dy = player.jumpPower * PLAYER_BOUNCE_POWER_MULTIPLIER; // Bounce up
                         player.grounded = false;
                         playSound('bounce');
                         collisionResult.obstacle.isKnocked = true; // Knock obstacle
                         score += 100; // Score for bouncing
                         currentScoreSpan.textContent = Math.floor(score);
                         console.log(`Knocked off: ${collisionResult.obstacle.assetKey}`);
                         // Update player immediately after bounce to apply dy
                         updatePlayer(dt); // Apply the bounce velocity this frame
                         collisionHandledThisFrame = true; // Collision handled
                     }

                     // Update player only if no collision was handled this frame
                     // (Bounce already includes a player update)
                     if (!collisionHandledThisFrame) {
                         updatePlayer(dt);
                     }

                     // Update obstacles and score regardless of collision outcome (if still playing)
                     if (currentGameState === GameState.PLAYING) {
                         updateObstacles(dt, timestamp);
                         updateScoreAndSpeed(dt); // Pass dt here
                     }
                 }

                 // --- Drawing ---
                 ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
                 drawBackground(dt); // Draw new background first
                 drawObstacles();    // Draw obstacles on top
                 updateKnightVisuals(); // Update/draw player sprite (HTML element)

                 // Draw Loading Text if needed
                 if (currentGameState === GameState.LOADING) {
                     ctx.fillStyle = 'white';
                     ctx.font = `20px "${getComputedStyle(document.documentElement).getPropertyValue('--font-pixel').trim()}"`; // Use CSS variable for font
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText('Loading Assets...', canvasWidth / 2, canvasHeight / 2);
                 }

                 requestAnimationFrame(gameLoop); // Loop
            }


            // --- Start/Restart Game ---
            function startGame() {
                console.log("Attempting startGame(). Current state:", currentGameState, "Assets loaded?", allAssetsLoaded);
                if (currentGameState === GameState.PLAYING || !allAssetsLoaded) { console.log("startGame() aborted."); return; }
                console.log("Executing startGame()...");
                resetGame(); // Reset all variables and positions
                currentGameState = GameState.PLAYING;
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
                scoreDisplay.classList.remove('hidden');
                livesDisplay.classList.remove('hidden');
                knightImageEl.style.display = 'block'; // Make sure knight is visible
                knightImageEl.style.opacity = '1';
                currentKnightVisualState = null; // Reset visual state
                updateKnightVisuals(); // Position knight correctly
                playSound('start');
                lastTime = performance.now(); // Set start time for dt calculation
                // No need to call gameLoop here, it's already running via requestAnimationFrame
            }
            function restartGame() {
                console.log("Attempting restartGame(). Current state:", currentGameState);
                // Allow restart from GAME_OVER state even if assets are still loading (should be loaded anyway)
                if (currentGameState === GameState.PLAYING) return;
                console.log("Executing restartGame()...");
                startGame(); // Simply call startGame to reset and begin
            }

            // --- Handle Jump Input ---
            function handleJumpInput() {
                 console.log("handleJumpInput called. State:", currentGameState, "Paused:", isPaused, "Grounded:", player.grounded);
                 // Allow jump only when playing, not paused, and on the ground
                 if (currentGameState === GameState.PLAYING && !isPaused && player.grounded) {
                     player.dy = player.jumpPower; // Apply jump force
                     player.grounded = false;      // Player is now airborne
                     playSound('jump');
                 }
             }

            // --- Input Event Handlers ---
            function handleKeyDown(e) {
                 // Close POI overlay with Enter key
                 if ((e.key === 'Enter' || e.keyCode === 13) && poiOverlay.classList.contains('visible')) {
                     e.preventDefault();
                     console.log("Enter key pressed while POI visible. Closing POI.");
                     closePoiOverlay();
                     return; // Don't process other keys if closing POI
                 }

                 // Handle game actions based on state
                 switch (e.key) {
                     case ' ':       // Space bar
                     case 'ArrowUp': // Up arrow
                         e.preventDefault();
                         if (!allAssetsLoaded) return; // Don't act if assets not loaded

                         if (currentGameState === GameState.PLAYING) {
                             handleJumpInput(); // Jump if playing
                         } else if (currentGameState === GameState.MENU) {
                             startGame(); // Start if on menu
                         } else if (currentGameState === GameState.GAME_OVER) {
                             restartGame(); // Restart if game over
                         }
                         break;
                     case 'ArrowLeft': // Left arrow
                         e.preventDefault();
                         if (currentGameState === GameState.PLAYING && !isPaused) {
                             isPressingLeft = true;
                         }
                         break;
                     case 'ArrowRight': // Right arrow
                         e.preventDefault();
                         if (currentGameState === GameState.PLAYING && !isPaused) {
                             isPressingRight = true;
                         }
                         break;
                 }
             }
            function handleKeyUp(e) {
                 // Stop movement when keys are released
                 switch (e.key) {
                     case 'ArrowLeft':
                         isPressingLeft = false;
                         break;
                     case 'ArrowRight':
                         isPressingRight = false;
                         break;
                 }
             }
            function handleMouseClick(e) {
                 // Ignore clicks on specific UI elements handled elsewhere
                 if (e.target === closePoiButton || e.target === startButton || e.target === restartButton || joystickContainer.contains(e.target) || jumpButton.contains(e.target)) {
                     return;
                 }
                 console.log("Mouse click detected. State:", currentGameState, "Target:", e.target.id);
                 if (!allAssetsLoaded) return; // Ignore if assets not loaded

                 // If POI is visible, clicking anywhere outside the close button should close it
                 if (poiOverlay.classList.contains('visible')) {
                      console.log("Mouse click detected while POI visible. Closing POI.");
                      closePoiOverlay();
                      return; // Don't trigger game actions if closing POI
                 }

                 // Handle game actions based on state (Jump/Start/Restart)
                 switch (currentGameState) {
                     case GameState.PLAYING:
                         handleJumpInput(); // Jump if playing
                         break;
                     case GameState.MENU:
                         startGame(); // Start if on menu
                         break;
                     case GameState.GAME_OVER:
                         restartGame(); // Restart if game over
                         break;
                 }
             }
             function handleScreenTouch(e) {
                 // Prevent default touch behavior like scrolling or zooming
                 e.preventDefault();
                 if (!allAssetsLoaded) return;

                 // Ignore touches handled by specific controls (joystick, jump button, UI buttons)
                 const target = e.target;
                 if (joystickContainer.contains(target) || target === jumpButton || target === startButton || target === restartButton || target === closePoiButton) {
                     console.log("Touch ignored on gameContainer: Handled by specific control.");
                     return;
                 }

                 // If POI is visible, tapping anywhere closes it
                 if (poiOverlay.classList.contains('visible')) {
                      console.log("Screen touch detected while POI visible. Closing POI.");
                      closePoiOverlay();
                      return; // Don't trigger game actions if closing POI
                 }

                 // Handle game actions based on state (Jump/Start/Restart)
                 switch (currentGameState) {
                     case GameState.PLAYING:
                         // Only jump if the game is active and not paused
                         if (!isPaused) {
                             handleJumpInput();
                         }
                         break;
                     case GameState.MENU:
                         // Start game if tapping on the canvas or container area (not buttons)
                         if (target === canvas || target === gameContainer) {
                             startGame();
                         }
                         break;
                     case GameState.GAME_OVER:
                         // Restart game if tapping on the canvas or container area (not buttons)
                         if (target === canvas || target === gameContainer) {
                             restartGame();
                         }
                         break;
                 }
             }
            function handleJoystickStart(e) {
                 if (currentGameState !== GameState.PLAYING || isPaused) return;
                 e.preventDefault();
                 joystickBaseRect = joystickBase.getBoundingClientRect();
                 joystickRadius = joystickBaseRect.width / 2 - joystickKnob.offsetWidth / 2; // Max knob travel radius
                 joystickActive = true;
                 const touch = e.touches[0];
                 // Store starting position relative to the joystick *base* center for accurate delta calculation
                 const baseCenterX = joystickBaseRect.left + joystickBaseRect.width / 2;
                 const baseCenterY = joystickBaseRect.top + joystickBaseRect.height / 2;
                 joystickStartX = touch.clientX - baseCenterX;
                 joystickStartY = touch.clientY - baseCenterY;
                 // Move knob to touch start position immediately (clamped)
                 handleJoystickMove(e);
             }
            function handleJoystickMove(e) {
                 if (!joystickActive || currentGameState !== GameState.PLAYING || isPaused) return;
                 e.preventDefault();
                 const touch = e.touches[0];
                 // Calculate position relative to base center
                 const baseCenterX = joystickBaseRect.left + joystickBaseRect.width / 2;
                 const baseCenterY = joystickBaseRect.top + joystickBaseRect.height / 2;
                 let deltaX = touch.clientX - baseCenterX;
                 let deltaY = touch.clientY - baseCenterY;

                 // Calculate distance from center
                 const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                 // Clamp knob position within the base radius
                 let clampedX = deltaX;
                 let clampedY = deltaY;
                 if (dist > joystickRadius) {
                     const scale = joystickRadius / dist;
                     clampedX = deltaX * scale;
                     clampedY = deltaY * scale;
                 }

                 // Apply transform relative to the knob's own center (-50%, -50%)
                 joystickKnob.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;

                 // Determine movement direction based on deltaX (horizontal movement)
                 if (deltaX < -JOYSTICK_DEAD_ZONE) {
                     isPressingLeft = true;
                     isPressingRight = false;
                 } else if (deltaX > JOYSTICK_DEAD_ZONE) {
                     isPressingRight = true;
                     isPressingLeft = false;
                 } else {
                     // Within dead zone, no horizontal movement
                     isPressingLeft = false;
                     isPressingRight = false;
                 }
                 // Vertical delta (deltaY) is ignored for movement in this game
             }
            function handleJoystickEnd(e) {
                 if (!joystickActive) return;
                 // Check if the touch ending is the one controlling the joystick
                 let touchEnded = false;
                 if (e.changedTouches) {
                     for (let i = 0; i < e.changedTouches.length; i++) {
                         // Ideally, store the touch identifier in handleJoystickStart and check here
                         // For simplicity, we assume any touchend while active resets it.
                         touchEnded = true;
                         break;
                     }
                 } else {
                     touchEnded = true; // Assume mouseup or similar event
                 }

                 if (touchEnded) {
                     e.preventDefault();
                     joystickKnob.style.transform = 'translate(-50%, -50%)'; // Reset knob position
                     joystickActive = false;
                     isPressingLeft = false; // Stop movement
                     isPressingRight = false;
                 }
             }

            // --- Resize Canvas ---
            function resizeCanvas() {
                 const containerWidth = gameContainer.clientWidth;
                 const containerHeight = gameContainer.clientHeight;

                 // Prevent resizing to zero dimensions which can cause errors
                 if (containerWidth <= 0 || containerHeight <= 0) {
                     console.warn("Resize skipped: Container dimensions are zero or invalid.");
                     return;
                 }

                 canvasWidth = containerWidth;
                 canvasHeight = containerHeight;
                 canvas.width = canvasWidth;
                 canvas.height = canvasHeight;
                 console.log(`Canvas resized to: ${canvasWidth}x${canvasHeight}`);

                 // Recalculate dynamic game values based on new dimensions
                 groundHeightPx = canvasHeight * GROUND_HEIGHT_PERCENT;
                 collisionLandingTolerancePx = canvasHeight * COLLISION_LANDING_TOLERANCE_FACTOR;
                 obstacleSpeed = canvasWidth * OBSTACLE_SPEED_FACTOR; // Base speed scales with width
                 playerMaxDx = canvasWidth * PLAYER_MAX_DX_FACTOR;
                 playerAccel = canvasWidth * PLAYER_ACCEL_FACTOR;
                 player.gravity = canvasHeight / PLAYER_GRAVITY_FACTOR; // Gravity scales with height
                 player.jumpPower = canvasHeight / PLAYER_JUMP_FACTOR;   // Jump power scales with height

                 // Update player size based on whether it looks like a mobile device width
                 const isMobileWidth = window.innerWidth <= MOBILE_BREAKPOINT_WIDTH; // Use window width for breakpoint check
                 if (isMobileWidth) {
                     player.width = canvasWidth * PLAYER_WIDTH_PERCENT_MOBILE;
                     player.height = canvasHeight * PLAYER_HEIGHT_PERCENT_MOBILE;
                 } else {
                     player.width = canvasWidth * PLAYER_WIDTH_PERCENT_DESKTOP;
                     player.height = canvasHeight * PLAYER_HEIGHT_PERCENT_DESKTOP;
                 }

                 // Reposition player if game is initialized (avoid errors before init)
                 if (gameInitialized) {
                    // Ensure player stays on the ground after resize
                    player.y = canvasHeight - groundHeightPx - player.height;
                    // Prevent player from being pushed off-screen by resize
                    if (player.x + player.width > canvasWidth) {
                        player.x = canvasWidth - player.width;
                    }
                    if (player.x < 0) {
                        player.x = 0;
                    }
                 }

                 // Update joystick base rect for accurate touch calculations
                 if (joystickBase) {
                    joystickBaseRect = joystickBase.getBoundingClientRect();
                    joystickRadius = joystickBaseRect.width / 2 - joystickKnob.offsetWidth / 2;
                 }
             }

            // --- Initial Setup ---
            function initGame() {
                 if (gameInitialized || !allAssetsLoaded) {
                     console.log("initGame skipped. Initialized:", gameInitialized, "Assets Loaded:", allAssetsLoaded);
                     return; // Don't initialize multiple times or before assets load
                 }
                 console.log("Initializing Game...");
                 gameInitialized = true;

                 // Check essential assets needed for core gameplay before full init
                 if (!assets.knight_run.loaded || !assets.knight_jump.loaded) {
                     console.error("Essential knight assets failed to load!");
                     alert("Error: Essential knight images failed to load. Game cannot start.");
                     // Display error message on screen?
                     currentGameState = GameState.LOADING; // Stay in loading state
                     return; // Stop initialization
                 }

                 loadHighScore();
                 resizeCanvas(); // Perform initial resize and calculation of dynamic values

                 // Set initial UI state
                 startScreen.classList.remove('hidden');
                 gameOverScreen.classList.add('hidden');
                 scoreDisplay.classList.add('hidden');
                 livesDisplay.classList.add('hidden');
                 poiOverlay.classList.remove('visible');
                 knightImageEl.style.display = 'none'; // Start with knight hidden

                 // --- Event Listeners ---
                 // Remove potentially old listeners first to prevent duplicates
                 startButton.removeEventListener('click', startGame);
                 restartButton.removeEventListener('click', restartGame);
                 document.removeEventListener('keydown', handleKeyDown);
                 document.removeEventListener('keyup', handleKeyUp);
                 gameContainer.removeEventListener('touchstart', handleScreenTouch);
                 gameContainer.removeEventListener('click', handleMouseClick);
                 window.removeEventListener('resize', resizeCanvas);
                 closePoiButton.removeEventListener('click', closePoiOverlay);
                 poiOverlay.removeEventListener('touchstart', closePoiOverlay); // Touch on overlay itself to close
                 poiOverlay.removeEventListener('click', closePoiOverlay); // Click on overlay itself to close
                 joystickContainer.removeEventListener('touchstart', handleJoystickStart);
                 joystickContainer.removeEventListener('touchmove', handleJoystickMove);
                 joystickContainer.removeEventListener('touchend', handleJoystickEnd);
                 joystickContainer.removeEventListener('touchcancel', handleJoystickEnd);
                 jumpButton.removeEventListener('touchstart', handleJumpInput);
                 jumpButton.removeEventListener('click', handleJumpInput); // Add click listener for mouse users testing

                 // Add listeners
                 console.log("Attaching listeners...");
                 startButton.addEventListener('click', startGame);
                 restartButton.addEventListener('click', restartGame);
                 document.addEventListener('keydown', handleKeyDown);
                 document.addEventListener('keyup', handleKeyUp);
                 // Use capture phase for game container touch to potentially intercept before inner elements if needed, but generally false is fine.
                 // Passive: false is important for preventDefault() to work reliably on touch events.
                 gameContainer.addEventListener('touchstart', handleScreenTouch, { passive: false });
                 gameContainer.addEventListener('click', handleMouseClick); // Handles clicks on canvas/background
                 window.addEventListener('resize', resizeCanvas);
                 closePoiButton.addEventListener('click', closePoiOverlay);
                 poiOverlay.addEventListener('touchstart', closePoiOverlay, { passive: false }); // Allow closing by tapping overlay
                 poiOverlay.addEventListener('click', closePoiOverlay); // Allow closing by clicking overlay
                 joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
                 joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
                 joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
                 joystickContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
                 jumpButton.addEventListener('touchstart', handleJumpInput, { passive: false });
                 jumpButton.addEventListener('click', handleJumpInput); // Add click listener
                 console.log("Event listeners attached.");

                 // Set initial game state and start the loop
                 currentGameState = GameState.MENU;
                 console.log("Set gameState to MENU");
                 lastTime = performance.now(); // Initialize timer
                 requestAnimationFrame(gameLoop); // Start the main game loop
                 console.log("Initial game loop requested.");
             }

            // --- Start Asset Loading on DOM Ready ---
            document.addEventListener('DOMContentLoaded', () => {
                console.log("DOM Ready. Starting asset load.");
                loadAssets(); // Begin loading all game assets
            });

        })(); // End of IIFE
    </script>
</body>
</html>
